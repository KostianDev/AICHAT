/*
 * AICHAT - Advanced Image Color Harmony Analysis and Transformation
 * Build configuration with Panama FFI native acceleration support
 */

plugins {
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'info.solidsoft.pitest' version '1.19.0-rc.2'
    id 'me.champeau.jmh' version '0.7.3'
}

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

javafx {
    version = "25"
    modules = ['javafx.controls', 'javafx.fxml', 'javafx.swing']
}

dependencies {
    implementation libs.guava
    
    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation 'net.jqwik:jqwik:1.9.3'
    testImplementation 'com.github.romankh3:image-comparison:4.4.0'
    
    jmh 'org.openjdk.jmh:jmh-core:1.37'
    jmh 'org.openjdk.jmh:jmh-generator-annprocess:1.37'
}

application {
    mainClass = 'aichat.App'
    applicationDefaultJvmArgs = [
        '--enable-native-access=javafx.graphics,ALL-UNNAMED',
        '-Djava.library.path=' + projectDir.absolutePath + '/src/main/resources/native/linux:' + 
                                 projectDir.parentFile.absolutePath + '/native/build'
    ]
}

tasks.register('buildNative', Exec) {
    workingDir "${project.rootDir}/native"
    commandLine 'make', 'clean', 'all'
    ignoreExitValue = true
    doFirst { println "Building native library for current platform..." }
}

tasks.register('buildNativeAll', Exec) {
    workingDir "${project.rootDir}/native"
    commandLine 'make', 'all-platforms'
    ignoreExitValue = true
    doFirst { println "Building native library for all platforms..." }
}

tasks.named('run') {
    dependsOn 'buildNative'
}

def testResultsDir = file("${project.rootDir}/test-results")

tasks.named('test') {
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    include '**/*Properties.class'
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    
    systemProperty 'force.java', System.getProperty('force.java', 'false')
    // Don't set native.variant for default tests - uses main libaichat_native library
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/test")
        junitXml.outputLocation = file("${testResultsDir}/junit/test")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}

tasks.register('testJava', Test) {
    description = 'Run tests with Java-only implementation (no native acceleration)'
    group = 'verification'
    dependsOn 'compileTestJava', 'processTestResources'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    include '**/*Properties.class'
    
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    systemProperty 'force.java', 'true'
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/testJava")
        junitXml.outputLocation = file("${testResultsDir}/junit/testJava")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║                    TEST PROFILE: JAVA FALLBACK                       ║
║  Running with -Dforce.java=true (native acceleration disabled)       ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

tasks.register('testNative', Test) {
    description = 'Run tests with native acceleration (default behavior)'
    group = 'verification'
    dependsOn 'buildNative', 'compileTestJava', 'processTestResources'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    include '**/*Properties.class'
    
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    systemProperty 'force.java', 'false'
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/testNative")
        junitXml.outputLocation = file("${testResultsDir}/junit/testNative")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
    
    doFirst {
        def gpu = ['lspci', '-nn'].execute().text.toLowerCase()
        if (gpu.contains('amd') || gpu.contains('radeon')) {
            environment 'RUSTICL_ENABLE', 'radeonsi'
            println "OpenCL: AMD GPU detected"
        } else if (gpu.contains('intel')) {
            environment 'RUSTICL_ENABLE', 'iris'
            println "OpenCL: Intel GPU detected"
        }
        println """
╔══════════════════════════════════════════════════════════════════════╗
║                    TEST PROFILE: NATIVE ACCELERATION                 ║
║  Running with native library (SIMD/OpenMP/OpenCL if available)       ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

tasks.register('testAllProfiles') {
    description = 'Run tests with both profiles: default (with native) and Java-only fallback'
    group = 'verification'
    
    // Run in sequence: default first (uses native), then Java fallback
    dependsOn 'test', 'testJava'
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║                    RUNNING ALL TEST PROFILES                         ║
╠══════════════════════════════════════════════════════════════════════╣
║  Phase 1: Default tests (uses native acceleration if available)      ║
║  Phase 2: Java-only fallback tests (force.java=true)                 ║
╠══════════════════════════════════════════════════════════════════════╣
║  Note: testNative is separate - use it when developing native code   ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
    
    doLast {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║                    ALL TEST PROFILES COMPLETED                       ║
╠══════════════════════════════════════════════════════════════════════╣
║  ✓ Default tests completed (native acceleration)                     ║
║  ✓ Java Fallback tests completed                                     ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

// Ensure testJava runs after test
tasks.named('testJava') {
    mustRunAfter 'test'
}

// Native variant testing tasks (for differential testing of optimization levels)
// These require building variants first: cd native && make variants

tasks.register('buildNativeVariants', Exec) {
    description = 'Build all native library variants (scalar, simd, openmp)'
    group = 'build'
    workingDir "${projectDir}/../native"
    commandLine 'make', 'variants'
}

tasks.register('testScalar', Test) {
    description = 'Run tests with SCALAR native library (no AVX2, no OpenMP)'
    group = 'verification'
    dependsOn 'buildNativeVariants', 'compileTestJava', 'processTestResources'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    systemProperty 'native.variant', 'scalar'
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/testScalar")
        junitXml.outputLocation = file("${testResultsDir}/junit/testScalar")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
    }
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║               NATIVE VARIANT: SCALAR (no optimizations)              ║
║  Testing baseline implementation without SIMD or parallel execution  ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

tasks.register('testSimd', Test) {
    description = 'Run tests with SIMD native library (AVX2, no OpenMP)'
    group = 'verification'
    dependsOn 'buildNativeVariants', 'compileTestJava', 'processTestResources'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    systemProperty 'native.variant', 'simd'
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/testSimd")
        junitXml.outputLocation = file("${testResultsDir}/junit/testSimd")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
    }
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║               NATIVE VARIANT: SIMD (AVX2 vectorization)              ║
║  Testing AVX2 SIMD implementation (single-threaded)                  ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

tasks.register('testOpenMP', Test) {
    description = 'Run tests with OpenMP native library (AVX2 + OpenMP)'
    group = 'verification'
    dependsOn 'buildNativeVariants', 'compileTestJava', 'processTestResources'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    useJUnitPlatform()
    include '**/*Test.class'
    include '**/*Tests.class'
    
    jvmArgs '--enable-native-access=ALL-UNNAMED'
    systemProperty 'native.variant', 'openmp'
    
    reports {
        html.outputLocation = file("${testResultsDir}/reports/testOpenMP")
        junitXml.outputLocation = file("${testResultsDir}/junit/testOpenMP")
    }
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
    }
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║               NATIVE VARIANT: OpenMP (AVX2 + parallelism)            ║
║  Testing full optimization: SIMD + multi-threaded parallel execution ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

tasks.register('testNativeVariants') {
    description = 'Run tests with all native library variants (scalar, simd, openmp)'
    group = 'verification'
    dependsOn 'testScalar', 'testSimd', 'testOpenMP'
    
    doFirst {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║              TESTING ALL NATIVE OPTIMIZATION VARIANTS                ║
╠══════════════════════════════════════════════════════════════════════╣
║  Phase 1: Scalar (baseline, no AVX2, no OpenMP)                      ║
║  Phase 2: SIMD (AVX2 vectorization, single-threaded)                 ║
║  Phase 3: OpenMP (AVX2 + parallel multi-threading)                   ║
╠══════════════════════════════════════════════════════════════════════╣
║  This validates that all optimization code paths are correct         ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
    
    doLast {
        println """
╔══════════════════════════════════════════════════════════════════════╗
║              ALL NATIVE VARIANTS TESTED SUCCESSFULLY                 ║
╠══════════════════════════════════════════════════════════════════════╣
║  ✓ Scalar variant: PASSED                                            ║
║  ✓ SIMD variant: PASSED                                              ║
║  ✓ OpenMP variant: PASSED                                            ║
╚══════════════════════════════════════════════════════════════════════╝
"""
    }
}

// Ensure variant tests run sequentially
tasks.named('testSimd') { mustRunAfter 'testScalar' }
tasks.named('testOpenMP') { mustRunAfter 'testSimd' }

pitest {
    targetClasses = ['aichat.color.ColorSpaceConverter', 'aichat.model.*']
    targetTests = ['aichat.*']
    pitestVersion = '1.20.3'
    junit5PluginVersion = '1.2.1'
    threads = 4
    outputFormats = ['HTML', 'XML']
    mutationThreshold = 70
    coverageThreshold = 90
    failWhenNoMutations = false
    jvmArgs = ['--enable-native-access=ALL-UNNAMED']
    excludedClasses = ['aichat.native_.*']
    reportDir = file("${project.rootDir}/test-results/pitest")
}

jmh {
    iterations = 3
    warmupIterations = 2
    fork = 1
    resultFormat = 'JSON'
    jvmArgs = ['--enable-native-access=ALL-UNNAMED']
    timeOnIteration = '1s'
    warmup = '1s'
    resultsFile = file("${project.rootDir}/test-results/jmh/results.json")
}

def currentOs = org.gradle.internal.os.OperatingSystem.current()
def platform = currentOs.isLinux() ? 'linux' : (currentOs.isMacOsX() ? 'macos' : 'windows')

tasks.register('portableDist', Sync) {
    description = 'Create portable distribution (requires Java 25+)'
    group = 'distribution'
    dependsOn 'buildNative', 'jar'
    
    into "${buildDir}/portable/aichat"
    
    from(configurations.runtimeClasspath) { into 'lib' }
    from(jar) { into 'lib' }
    from("${projectDir}/src/main/resources/native") { into 'native' }
    from("${projectDir}/../scripts") { into '.' }
    
    doLast {
        file("${buildDir}/portable/aichat/VERSION").text = 
            "AICHAT ${project.version}\nBuild: ${new Date()}\n"
        file("${buildDir}/portable/aichat/aichat.sh").setExecutable(true, false)
        println "Portable distribution: ${buildDir}/portable/aichat"
    }
}

tasks.register('portableZip', Zip) {
    description = 'Create portable ZIP (requires Java 25+)'
    group = 'distribution'
    dependsOn 'portableDist'
    from "${buildDir}/portable"
    archiveFileName = "aichat-portable-${project.version}.zip"
    destinationDirectory = file("${buildDir}/distributions")
}

tasks.register('portableTarGz', Tar) {
    description = 'Create portable tar.gz (requires Java 25+)'
    group = 'distribution'
    dependsOn 'portableDist'
    from "${buildDir}/portable"
    archiveFileName = "aichat-portable-${project.version}.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP
}

tasks.register('jlinkRuntime', Exec) {
    description = 'Create minimal JRE with JavaFX using jlink'
    group = 'distribution'
    dependsOn 'jar'
    
    def jlinkOutput = "${buildDir}/jlink-runtime"
    def javaHome = System.getProperty('java.home')
    def jlink = "${javaHome}/bin/jlink"
    def javafxJars = configurations.runtimeClasspath.files.findAll { 
        it.name.startsWith('javafx-') && it.name.contains("-${platform}") 
    }
    def modulePath = javafxJars.collect { it.absolutePath }.join(File.pathSeparator)
    
    doFirst { delete jlinkOutput }
    
    commandLine jlink,
        '--module-path', modulePath,
        '--add-modules', 'java.base,java.desktop,java.logging,java.prefs,java.xml,jdk.unsupported,javafx.controls,javafx.fxml,javafx.swing',
        '--output', jlinkOutput,
        '--strip-debug',
        '--compress', 'zip-6',
        '--no-header-files',
        '--no-man-pages'
    
    doLast {
        def size = file(jlinkOutput).directorySize() / 1024 / 1024
        println "Custom JRE: ${jlinkOutput} (${String.format('%.1f', size)} MB)"
    }
}

tasks.register('fullDist', Sync) {
    description = 'Create full distribution with bundled JRE (Linux only)'
    group = 'distribution'
    dependsOn 'buildNative', 'jar', 'jlinkRuntime'
    
    into "${buildDir}/full-dist/aichat"
    
    from("${buildDir}/jlink-runtime") { into 'jre' }
    from(configurations.runtimeClasspath.files.findAll { !it.name.startsWith('javafx-') }) { into 'lib' }
    from(jar) { into 'lib' }
    from("${projectDir}/src/main/resources/native/linux") { into 'native/linux' }
    from("${projectDir}/../scripts/README.md") { into '.' }
    
    doLast {
        createLinuxLauncher(file("${buildDir}/full-dist/aichat"))
        file("${buildDir}/full-dist/aichat/VERSION").text = 
            "AICHAT ${project.version}\nBuild: ${new Date()}\nBundled JRE: Java 25 (Linux x64)\n"
        println "Full distribution (Linux): ${buildDir}/full-dist/aichat"
    }
}

def createLinuxLauncher(File distDir) {
    def shScript = new File(distDir, 'aichat.sh')
    shScript.text = '''#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

JAVA="$SCRIPT_DIR/jre/bin/java"
[ ! -f "$JAVA" ] && echo "Error: Bundled JRE not found" && exit 1

# Fix permissions after ZIP extraction (ZIP doesn't preserve Unix permissions)
if [ ! -x "$JAVA" ]; then
    echo "Setting executable permissions for JRE..."
    chmod +x "$SCRIPT_DIR"/jre/bin/* 2>/dev/null
    chmod +x "$SCRIPT_DIR"/jre/lib/jexec 2>/dev/null
    chmod +x "$SCRIPT_DIR"/jre/lib/jspawnhelper 2>/dev/null
fi

echo "AICHAT - Advanced Image Color Harmony Analysis"
echo "================================================"

if [ -f /usr/lib/x86_64-linux-gnu/libMesaOpenCL.so ] || [ -f /usr/lib64/libMesaOpenCL.so ]; then
    lspci 2>/dev/null | grep -qi "AMD\\|Radeon" && export RUSTICL_ENABLE="${RUSTICL_ENABLE:-radeonsi}" && echo "AMD GPU detected"
    lspci 2>/dev/null | grep -qi "Intel.*Graphics" && export RUSTICL_ENABLE="${RUSTICL_ENABLE:-iris}" && echo "Intel GPU detected"
fi

export LD_LIBRARY_PATH="$SCRIPT_DIR/native/linux${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"

CLASSPATH=""
for jar in "$SCRIPT_DIR"/lib/*.jar; do
    [ -n "$CLASSPATH" ] && CLASSPATH="$CLASSPATH:$jar" || CLASSPATH="$jar"
done

exec "$JAVA" --enable-native-access=javafx.graphics,ALL-UNNAMED -Djava.library.path="$SCRIPT_DIR/native/linux" -cp "$CLASSPATH" aichat.App "$@"
'''
    shScript.setExecutable(true, false)
}

// Windows portable distribution (requires user to install Java 25+)
tasks.register('portableDistWindows', Sync) {
    description = 'Create portable Windows distribution (requires Java 25+)'
    group = 'distribution'
    dependsOn 'jar'
    
    into "${buildDir}/portable-windows/aichat"
    
    from(configurations.runtimeClasspath.files.findAll { !it.name.startsWith('javafx-') }) { into 'lib' }
    from(jar) { into 'lib' }
    from("${projectDir}/src/main/resources/native/windows") { into 'native/windows' }
    from("${projectDir}/../scripts/README.md") { into '.' }
    
    doLast {
        createWindowsLauncher(file("${buildDir}/portable-windows/aichat"))
        file("${buildDir}/portable-windows/aichat/VERSION").text = 
            "AICHAT ${project.version}\nBuild: ${new Date()}\nRequires: Java 25+ with JavaFX\n"
        println "Portable distribution (Windows): ${buildDir}/portable-windows/aichat"
    }
}

def createWindowsLauncher(File distDir) {
    def batScript = new File(distDir, 'aichat.bat')
    batScript.text = '''@echo off
setlocal enabledelayedexpansion
cd /d "%~dp0"
set SCRIPT_DIR=%CD%

REM Try bundled JRE first, then JAVA_HOME, then PATH
if exist "%SCRIPT_DIR%\\jre\\bin\\javaw.exe" (
    set JAVA=%SCRIPT_DIR%\\jre\\bin\\javaw.exe
) else if defined JAVA_HOME (
    set JAVA=%JAVA_HOME%\\bin\\javaw.exe
) else (
    where javaw >nul 2>&1
    if %ERRORLEVEL% equ 0 (
        set JAVA=javaw
    ) else (
        echo Error: Java not found. Please install Java 25+ or set JAVA_HOME
        pause
        exit /b 1
    )
)

set NATIVE_DIR=%SCRIPT_DIR%\\native\\windows

set CLASSPATH=
for %%j in ("%SCRIPT_DIR%\\lib\\*.jar") do (
    if defined CLASSPATH (set CLASSPATH=!CLASSPATH!;%%j) else (set CLASSPATH=%%j)
)

start "" "%JAVA%" --enable-native-access=ALL-UNNAMED -Djava.library.path="%NATIVE_DIR%" -cp "%CLASSPATH%" aichat.App %*
'''
}

// Download Windows JRE (Liberica JDK Full with JavaFX)
tasks.register('downloadWindowsJre') {
    description = 'Download Windows JRE with JavaFX for bundled distribution'
    group = 'distribution'
    
    def jreDir = file("${buildDir}/windows-jre")
    def jreZip = file("${buildDir}/liberica-jdk-windows.zip")
    // Liberica JDK 25 Full (with JavaFX) for Windows x64
    def jreUrl = 'https://github.com/bell-sw/Liberica/releases/download/25.0.1+11/bellsoft-jdk25.0.1+11-windows-amd64-full.zip'
    
    outputs.dir(jreDir)
    
    doLast {
        if (!jreDir.exists() || jreDir.listFiles()?.length == 0) {
            println "Downloading Windows JRE (~220MB)..."
            if (!jreZip.exists()) {
                ant.get(src: jreUrl, dest: jreZip, verbose: true)
            }
            println "Extracting Windows JRE..."
            delete jreDir
            copy {
                from zipTree(jreZip)
                into jreDir
                eachFile { fcd ->
                    // Remove top-level directory (jdk-25.0.1-full)
                    def segments = fcd.relativePath.segments
                    if (segments.length > 1) {
                        fcd.relativePath = new RelativePath(!fcd.file.isDirectory(), segments[1..-1] as String[])
                    } else {
                        fcd.exclude()
                    }
                }
                includeEmptyDirs = false
            }
            println "Windows JRE ready: ${jreDir}"
        } else {
            println "Windows JRE already exists: ${jreDir}"
        }
    }
}

// Full Windows distribution with bundled JRE
tasks.register('fullDistWindows', Sync) {
    description = 'Create full Windows distribution with bundled JRE'
    group = 'distribution'
    dependsOn 'jar', 'downloadWindowsJre'
    
    into "${buildDir}/full-dist-windows/aichat"
    
    from("${buildDir}/windows-jre") { into 'jre' }
    from(configurations.runtimeClasspath.files.findAll { !it.name.startsWith('javafx-') }) { into 'lib' }
    from(jar) { into 'lib' }
    from("${projectDir}/src/main/resources/native/windows") { into 'native/windows' }
    from("${projectDir}/../scripts/README.md") { into '.' }
    
    doLast {
        createWindowsLauncher(file("${buildDir}/full-dist-windows/aichat"))
        file("${buildDir}/full-dist-windows/aichat/VERSION").text = 
            "AICHAT ${project.version}\nBuild: ${new Date()}\nBundled JRE: Liberica JDK 25 Full (Windows x64)\n"
        println "Full distribution (Windows): ${buildDir}/full-dist-windows/aichat"
    }
}

tasks.register('fullDistWindowsZip', Zip) {
    description = 'Create full Windows distribution ZIP with bundled JRE'
    group = 'distribution'
    dependsOn 'fullDistWindows'
    from "${buildDir}/full-dist-windows"
    archiveFileName = "aichat-full-${project.version}-windows.zip"
    destinationDirectory = file("${buildDir}/distributions")
    doLast {
        def size = archiveFile.get().asFile.length() / 1024 / 1024
        println "Created: ${archiveFileName.get()} (${String.format('%.1f', size)} MB)"
    }
}

tasks.register('portableDistWindowsZip', Zip) {
    description = 'Create portable Windows ZIP (requires Java 25+)'
    group = 'distribution'
    dependsOn 'portableDistWindows'
    from "${buildDir}/portable-windows"
    archiveFileName = "aichat-portable-${project.version}-windows.zip"
    destinationDirectory = file("${buildDir}/distributions")
    doLast {
        def size = archiveFile.get().asFile.length() / 1024 / 1024
        println "Created: ${archiveFileName.get()} (${String.format('%.1f', size)} MB)"
    }
}

tasks.register('fullDistZip', Zip) {
    description = 'Create full Linux distribution ZIP with bundled JRE'
    group = 'distribution'
    dependsOn 'fullDist'
    from "${buildDir}/full-dist"
    archiveFileName = "aichat-full-${project.version}-linux.zip"
    destinationDirectory = file("${buildDir}/distributions")
    doLast {
        def size = archiveFile.get().asFile.length() / 1024 / 1024
        println "Created: ${archiveFileName.get()} (${String.format('%.1f', size)} MB)"
    }
}

tasks.register('fullDistTarGz', Tar) {
    description = 'Create full Linux distribution tar.gz with bundled JRE'
    group = 'distribution'
    dependsOn 'fullDist'
    from "${buildDir}/full-dist"
    archiveFileName = "aichat-full-${project.version}-linux.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP
    doLast {
        def size = archiveFile.get().asFile.length() / 1024 / 1024
        println "Created: ${archiveFileName.get()} (${String.format('%.1f', size)} MB)"
    }
}

tasks.register('allDist') {
    description = 'Build all distribution archives'
    group = 'distribution'
    dependsOn 'fullDistZip', 'fullDistWindowsZip'
    doLast {
        println "\n=== All distributions created ==="
        file("${buildDir}/distributions").listFiles()?.each { println "  ${it.name}" }
    }
}

tasks.register('allTests') {
    description = 'Run all tests: default + Java fallback + native variants, JMH benchmarks, and Pitest mutation testing'
    group = 'verification'
    
    doFirst {
        println '''
╔══════════════════════════════════════════════════════════════════════╗
║                    AICHAT Comprehensive Test Suite                   ║
╠══════════════════════════════════════════════════════════════════════╣
║  Phase 1: Default Tests (with native acceleration)                   ║
║  Phase 2: Java-only Fallback Tests (verify pure Java works)          ║
║  Phase 2.5: Native Variants (scalar/simd/openmp)                     ║
║  Phase 3: JMH Benchmarks (performance validation)                    ║
║  Phase 4: Pitest Mutation Testing (code quality)                     ║
╚══════════════════════════════════════════════════════════════════════╝
'''
    }
}

tasks.register('testPhase1') {
    description = 'Phase 1: Run all unit tests and property-based tests (default profile)'
    group = 'verification'
    dependsOn 'test'
    
    doFirst {
        println "\n═══ Phase 1: Default Tests (auto-detect native) ═══"
    }
    doLast {
        println "✓ Phase 1 completed: Default tests passed"
    }
}

tasks.register('testPhase2Java') {
    description = 'Phase 2: Run tests with Java-only fallback'
    group = 'verification'
    dependsOn 'testPhase1'
    mustRunAfter 'testPhase1'
    
    doFirst {
        println "\n═══ Phase 2: Java-only Fallback Tests ═══"
    }
    
    finalizedBy 'testJava'
}

tasks.register('testPhase2NativeVariants') {
    description = 'Phase 2.5: Run tests with native library variants (scalar, simd, openmp)'
    group = 'verification'
    dependsOn 'testPhase2Java'
    mustRunAfter 'testPhase2Java'
    
    doFirst {
        println "\n═══ Phase 2.5: Native Optimization Variants ═══"
    }
    
    finalizedBy 'testNativeVariants'
}

tasks.register('testPhase3Benchmark') {
    description = 'Phase 3: Run JMH benchmarks (quick mode)'
    group = 'verification'
    dependsOn 'testPhase2NativeVariants'
    mustRunAfter 'testPhase2NativeVariants'
    
    doFirst {
        println "\n═══ Phase 3: JMH Benchmarks ═══"
    }
    
    finalizedBy 'jmh'
}

tasks.register('testPhase4Mutation') {
    description = 'Phase 4: Run Pitest mutation testing'
    group = 'verification'
    dependsOn 'testPhase1'
    mustRunAfter 'testPhase3Benchmark'
    
    doFirst {
        println "\n═══ Phase 4: Pitest Mutation Testing ═══"
    }
    
    finalizedBy 'pitest'
}

allTests {
    dependsOn 'testPhase1', 'testPhase2Java', 'testPhase2NativeVariants', 'testPhase3Benchmark', 'testPhase4Mutation'
    
    doLast {
        println '''
╔══════════════════════════════════════════════════════════════════════╗
║                         Test Suite Complete                          ║
╠══════════════════════════════════════════════════════════════════════╣
║  Reports (all in test-results/):                                     ║
║    • Default Tests:   test-results/reports/test/index.html           ║
║    • Java Tests:      test-results/reports/testJava/index.html       ║
║    • Native Variants: test-results/reports/testScalar|Simd|OpenMP/   ║
║    • Performance:     test-results/performance/                      ║
║    • JMH:             test-results/jmh/results.json                  ║
║    • Pitest:          test-results/pitest/index.html                 ║
╚══════════════════════════════════════════════════════════════════════╝
'''
    }
}

tasks.register('quickTest') {
    description = 'Quick test: only unit tests and PBT (skip JMH and Pitest)'
    group = 'verification'
    dependsOn 'test'
    
    doLast {
        println "\n✓ Quick test completed (use 'allTests' for full suite)"
    }
}
